pragma cashscript ^0.12.0;

// SwapOutRedemption loan contract function
// Is used by an existing redemption, to change target of the redemption to be a lower interest loan than the original target loan
// This function is attached to the higher interest loan that is being swapped out

/*  --- State Immutable NFT ---
    byte identifier == 0x06
*/

// minimumLoanDebtForSwapOut = 100.00 ParityUSD

contract swapOutRedemption(
  bytes32 redemptionTokenId
  ) {
      // function swapOutRedemption
      // Swaps the taget loan of an active redemption out for a lower interest paying loan
      // The redemption can pay for the transaction fees of one redemption-swap (normally no external fee input required).
      //
      // Inputs: 00-loan, 01-loanTokenSidecar, 02-swapOutRedemption, 03-redemption, 04-redemptionStateSidecar, 05-redemptionTokenSidecar, 06-loanLowerInterest, 07-loanTokenSidecar, 08-swapInRedemption, ?09-feeBch
      // Outputs: 00-loan, 01-loanTokenSidecar, 02-swapOutRedemption, 03-redemption, 04-redemptionStateSidecar, 05-redemptionTokenSidecar, 06-loanLowerInterest, 07-loanTokenSidecar, 08-swapInRedemption, ?09-changeBch

    function swapOutRedemption(){
      // Require function to be at inputIndex 2
      require(this.activeInputIndex == 2);
      bytes parityTokenId = tx.inputs[this.activeInputIndex].tokenCategory;

      // Authenticate Loan being redeemed at inputIndex 0, nftCommitment checked below
      require(tx.inputs[0].tokenCategory == parityTokenId + 0x01);

      // Parse loan state
      bytes loanState = tx.inputs[0].nftCommitment;
      bytes7 firstPartLoanState, bytes remainingPartLoanState = loanState.split(7);
      byte identifier, bytes6 borrowedAmountBytes = firstPartLoanState.split(1);
      require(identifier == 0x01);
      bytes6 amountBeingRedeemed, bytes lastPartLoanState = remainingPartLoanState.split(6);

      // Loan can only be swapped out if the current loan meets minimum debt threshold
      // Check minimumLoanDebtForSwapOut
      require(int(borrowedAmountBytes) >= 100_00);

      // Authenticate redemption
      require(tx.inputs[3].tokenCategory == redemptionTokenId + 0x01);

      // Parse redemption state
      bytes32 targetLoan, bytes redemptionAmountBytes = tx.inputs[3].nftCommitment.split(32);

      // Require target loan to match tokenId
      require(tx.inputs[1].tokenCategory == targetLoan);

      // Construct new loan state
      int newRedemptionAmount = int(amountBeingRedeemed) - int(redemptionAmountBytes);
      bytes27 newLoanState = firstPartLoanState + bytes6(newRedemptionAmount) + bytes14(lastPartLoanState);

      // Recreate loan contract with new state at outputIndex 0
      require(tx.outputs[0].nftCommitment == newLoanState, "Invalid state loan contract - wrong nftCommitment");
      require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode, "Recreate loan contract - invalid lockingBytecode");
      require(tx.outputs[0].value == tx.inputs[0].value, "Recreate loan contract with same BCH amount");
      require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory, "Recreate loan contract - invalid tokenCategory");
      require(tx.outputs[0].tokenAmount == 0, "Recreate loan contract - should have zero token amount");

      // Recreate functionContract at output index 2
      require(tx.outputs[2].lockingBytecode == tx.inputs[2].lockingBytecode);
      require(tx.outputs[2].nftCommitment == tx.inputs[2].nftCommitment);
      require(tx.outputs[2].tokenCategory == tx.inputs[2].tokenCategory);
      require(tx.outputs[2].value == 1000);
      require(tx.outputs[2].tokenAmount == 0);
    }
}