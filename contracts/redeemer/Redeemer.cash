pragma cashscript ^0.12.0;

// Redeemer contract, creates the individual redemptions for loans.

/*  --- Minting NFT ---
    no state (0x)
*/

contract Redeemer(
  bytes32 parityTokenId,
  bytes redemptionLockingScript,
  bytes tokenSidecarLockingScript
  ) {
      // function createRedemption
      // Creates a redemption with two tokensidecars to keep state and hold parity tokens.
      //
      // Inputs: 00-PriceContract, 01-Loan, 02-loanTokenSidecar, 03-startRedemption, 04-redeemer, 0?-Parity-tokens, 0?-feeBch
      // Outputs: 00-PriceContract, 01-Loan, 02-loanTokenSidecar, 03-startRedemption, 04-redeemer, 05-redemption, 06-redemptionStateSidecar, 07-redemptionTokenSidecar, ??-changeBch

    function createRedemption(
      int redeemAmountTokens,
      // Note: the bytes length of function arguments are not automatically enforced
      bytes20 redeemerPkh
    ){
      // Require Redeemer to be at inputIndex 4
      require(this.activeInputIndex == 4);

      // Authenticate PriceContract at inputIndex 0
      require(tx.inputs[0].tokenCategory == parityTokenId + 0x01);
      require(tx.inputs[0].nftCommitment.split(1)[0] == 0x00);

      // Authenticate Loan at inputIndex 1
      require(tx.inputs[1].tokenCategory == parityTokenId + 0x01);
      require(tx.inputs[1].nftCommitment.split(1)[0] == 0x01);

      // Authenticate Redeem function NFT at inputIndex 3
      require(tx.inputs[3].tokenCategory == parityTokenId);
      require(tx.inputs[3].nftCommitment.split(1)[0] == 0x04);

      // Validate redeemerPkh input
      require(redeemerPkh.length == 20);

      // Check redeemAmountTokens to be positive
      // Specific minimumRedeemAmount check is done in startRedemption function
      require(redeemAmountTokens > 0);

      // Recreate redeemer at output index 4
      require(tx.outputs[4].value == 1000);
      require(tx.outputs[4].lockingBytecode == tx.inputs[4].lockingBytecode);
      require(tx.outputs[4].tokenCategory == tx.inputs[4].tokenCategory);
      require(tx.outputs[4].nftCommitment == 0x);
      bytes32 redemptionTokenCategory = tx.inputs[4].tokenCategory.split(32)[0];

      // Construct new mutable state redemption
      bytes loanTokenId = tx.inputs[2].tokenCategory;
      bytes6 redeemAmountTokensBytes = bytes6(redeemAmountTokens);
      // Semantic typecast of 'loanTokenId' so the concatenated result is bytes38
      bytes38 mutableRedemptionState = bytes32(loanTokenId) + redeemAmountTokensBytes;

      // Create redemption at output index 5
      // Redemption has 5000 sats to pay for its own swapRedemption if needed
      require(tx.outputs[5].value == 5000);
      require(tx.outputs[5].tokenCategory == redemptionTokenCategory + 0x01);
      require(tx.outputs[5].lockingBytecode == redemptionLockingScript);
      require(tx.outputs[5].nftCommitment == mutableRedemptionState);

      // Read latest price from PriceContract contract
      bytes4 oraclePriceBytes = tx.inputs[0].nftCommitment.slice(5,9);
      int oraclePrice = int(oraclePriceBytes);

      // Calculate redemptionPrice which is 0.5% below oracle price
      int redemptionPrice = oraclePrice * 995 / 1000;
      // Construct immutable state redemptionSidecar
      bytes24 redemptionSidecarState = redeemerPkh + bytes4(redemptionPrice);

      // Create redemption statesidecar at output index 6
      require(tx.outputs[6].value == 1000);
      require(tx.outputs[6].tokenCategory == redemptionTokenCategory);
      require(tx.outputs[6].lockingBytecode == tokenSidecarLockingScript);
      require(tx.outputs[6].nftCommitment == redemptionSidecarState);

      // Create redemption tokensidecar at output index 7
      require(tx.outputs[7].value == 1000);
      require(tx.outputs[7].lockingBytecode == tokenSidecarLockingScript);
      require(tx.outputs[7].tokenCategory == parityTokenId);
      require(tx.outputs[7].tokenAmount == redeemAmountTokens);

      // Optional ninth output for token change or BCH change
      if (tx.outputs.length > 8) {
        // Protect minting capability
        bool noTokenOrParityTokens = tx.outputs[8].tokenCategory == 0x || tx.outputs[8].tokenCategory == parityTokenId;
        require(noTokenOrParityTokens);
      }

      // Optional tenth output for BCH change
      if (tx.outputs.length > 9) {
        require(tx.outputs[9].tokenCategory == 0x);
      }

      // Restrict maximum outputs to 10 total to protect minting capability
      require(tx.outputs.length <= 10);
    }
}