pragma cashscript ^0.12.0;

// StabilityPoolSidecar contract holding ParityUSD tokens for the pool
// Custom sidecar allowing for special outputIndex when called from liquidateLoan function
// Has extra check so it can only hold ParityUSD tokens or no tokens at all

// Holds the ParityUSD tokens
/*  --- No NFT ---  */

contract StabilityPoolSidecar(
    bytes32 parityTokenId
  ) {
  function attach() {
    // Authenticate StabilityPool
    int stabilityPoolInputIndex = this.activeInputIndex - 1;
    require(tx.inputs[this.activeInputIndex].outpointTransactionHash == tx.inputs[stabilityPoolInputIndex].outpointTransactionHash);
    require(tx.inputs[this.activeInputIndex].outpointIndex == tx.inputs[stabilityPoolInputIndex].outpointIndex + 1);

    // Special outputIndex for liquidateLoan function
    int outputIndex = this.activeInputIndex;
    int nftFunctionInputIndex = this.activeInputIndex + 1;
    bytes commitmentNftFunction = tx.inputs[nftFunctionInputIndex].nftCommitment;
    if(commitmentNftFunction == 0x02) outputIndex = 3;

    // Recreate TokenSidecar (same value, lockingBytecode, no nft)
    require(tx.outputs[outputIndex].value == 1000);
    require(tx.outputs[outputIndex].lockingBytecode == tx.inputs[this.activeInputIndex].lockingBytecode);
    require(tx.outputs[outputIndex].nftCommitment == 0x);

    // TokenSidecar either holds parity tokens or no tokens (zero balance)
    bool hasParityTokenId = tx.outputs[outputIndex].tokenCategory == parityTokenId;
    bool hasNoTokens = tx.outputs[outputIndex].tokenCategory == 0x;
    require(hasParityTokenId || hasNoTokens);
  }
}