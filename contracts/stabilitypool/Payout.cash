pragma cashscript ^0.12.0;

// Contract to payout rewards stability pool
// One Payout contract is created per epoch in (every 10th invocation of) the 'NewPeriodPool' function of the StabilityPool contract

/*  --- State Payout Minting NFT ---
    bytes4 period
    bytes6 totalStakedEpoch (tokens)
    bytes6 remainingStakedEpoch (tokens)
    bytes totalClaimValue (BCH)
*/

/*  --- State Receipts Immutable NFT ---
    bytes4 period
    bytes amountStakedReceipt (tokens)
*/

// Note: In practice the 'periodReceipt' state is only used to derive the corresponding epoch (periodReceipt / 10)

contract Payout() {
    // function claim
    // Allows ParityUSD depositor to claim the portion of the interest they were entitled to in the period.
    //
    // Inputs: 00-Payout, 01-userReceipt, ?02-feeBch
    // Outputs: 00-Payout, 01-newUserReceipt, 02-userBchPayout

  function claim() {
    // Require contract to be at inputIndex 0
    require(this.activeInputIndex == 0, "Payout contract must always be at input index 0");

    // Parse state Payout contract
    bytes4 periodPayoutBytes, bytes remainingState = tx.inputs[0].nftCommitment.split(4);
    bytes6 totalStakedEpochBytes, bytes remainingState2 = remainingState.split(6);
    bytes6 remainingStakedEpochBytes, bytes totalClaimValueBytes = remainingState2.split(6);

    // Authenticate staking receipt
    bytes32 stabilityPoolTokenId = tx.inputs[0].tokenCategory.split(32)[0];
    require(tx.inputs[1].tokenCategory == stabilityPoolTokenId, "Invalid claim receipt, should have correct tokenId");

    // Parse state staking receipt
    bytes stateReceipt = tx.inputs[1].nftCommitment;
    bytes4 periodReceiptBytes, bytes amountStakedReceiptBytes = stateReceipt.split(4);

    // Check period receipt, should be in the same staking epoch (10 periods) as currentPeriod
    int periodPayout = int(periodPayoutBytes);
    int periodReceipt = int(periodReceiptBytes);
    require(periodReceipt / 10 == periodPayout / 10, "Invalid claim receipt, should be from the correct period");

    // Calculate user claim
    int claimAmount = 0;
    int totalStakedEpoch = int(totalStakedEpochBytes);
    int amountStakedReceipt = int(amountStakedReceiptBytes);
    // Prevent division by zero
    if(totalStakedEpoch != 0){
      claimAmount= int(totalClaimValueBytes) * amountStakedReceipt / totalStakedEpoch;
    }
    
    // Recreate Payout contract with lower bch amount at outputIndex 0
    int newAmountPayoutContract = tx.inputs[0].value - claimAmount;
    require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory, "Recreate contract at output0 - invalid tokenCategory");
    require(tx.outputs[0].nftCommitment == tx.inputs[0].nftCommitment, "Recreate contract at output0 - invalid nftCommitment");
    require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode, "Recreate contract at output0 - invalid lockingBytecode");
    require(tx.outputs[0].value == newAmountPayoutContract, "Recreate contract at output0 - invalid BCH amount");

    // Construct new receipt state
    int remainingStakedEpoch = int(remainingStakedEpochBytes);
    int newAmountStaked = amountStakedReceipt * remainingStakedEpoch / totalStakedEpoch;
    int newPeriodReceipt = periodPayout + 10;
    bytes newReceipt = bytes4(newPeriodReceipt) + bytes(newAmountStaked);

    // Create new user receipt output at outputIndex 1
    require(tx.outputs[1].tokenCategory == tx.inputs[1].tokenCategory);
    require(tx.outputs[1].nftCommitment == newReceipt, "Invalid new receipt, should have correct nftCommitment");
    require(tx.outputs[1].value == 1000, "Invalid tokenoutput - needs to hold exactly 1000 sats");

    // User Bch Payout output at outputIndex 2
    // Allow for token category, disallow for StabilityPool/Payout category to be used
    // Enables future extension of automatic payout distribution contract
    bytes tokenCategoryOutput2 = tx.outputs[2].tokenCategory;
    if(tokenCategoryOutput2 != 0x) require(tokenCategoryOutput2.split(32)[0] != stabilityPoolTokenId);

    // Don't allow more outputs to prevent minting extra NFTs.
    require(tx.outputs.length <= 3, "Invalid number of outputs - should have 3 at most");
  }
}