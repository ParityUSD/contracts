pragma cashscript ^0.12.0;

// Pricecontract keeps track of the latest BCH/USD price state and shares it with other contracts
// The Pricecontract accepts signed price info and validates it against the oracle's PublicKey
// Additionally the pricecontract shares its state with other contracts
// The Pricecontract can be migrated to updated contract code by a MigrationKey

/*  --- State Mutable NFT ---
    byte identifier == 0x00
    bytes4 sequence,
    bytes4 pricedata
    (can be extended in the future with extra fields by migrating the pricecontracts)
*/

contract PriceContract(
  pubkey oraclePublicKey,
  bytes32 tokenIdMigrationKey
  ) {
    // function updatePrice
    // Update the pricecontract mutable NFT state with newer oracle price data
    //
    // Inputs: 00-pricecontract, ?01-feeBch
    // Outputs: 00-pricecontract, ?01-changeBch

  function updatePrice(
    // bytes16 oracleMessage
    // {
    //     bytes4 messageTimestamp;
    //     bytes4 messageSequence;
    //     bytes4 contentSequence;
    //     bytes4 contentData / price;
    // }
    bytes oracleMessage,
    datasig oracleSignature
  ) {
    // Require contract to be at inputIndex 0
    require(this.activeInputIndex == 0, "Price contract must be at input index 0");

    // Replicate price contract output 
    require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode, "Recreate contract at output0 - invalid lockingBytecode");
    require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory, "Recreate contract at output0 - invalid tokenCategory");
    require(tx.outputs[0].value == 1000, "Recreate contract at output0 - needs to hold exactly 1000 sats");
    require(tx.outputs[0].tokenAmount == 0, "Recreate contract at output0 - tokenAmount must be zero");

    // Validate oracle signature against the oracle public key
    require(checkDataSig(oracleSignature, oracleMessage, oraclePublicKey));

    // Extract oracle message's content sequence and price
    bytes oraclePriceInfo = oracleMessage.split(8)[1];
    bytes4 oracleSeqBytes, bytes oraclePriceBytes = oraclePriceInfo.split(4);

    // Heartbeat updates are the sequence numbers that are multiples of 10
    int oracleSeq = int(oracleSeqBytes);
    bool oracleHeartbeat = oracleSeq % 10 == 0;

    // Parse contract sequence and price from the current contract state
    bytes contractPriceState = tx.inputs[0].nftCommitment.split(1)[1];
    bytes4 contractSeqBytes, bytes contractPriceBytes = contractPriceState.split(4);

    // Calculate price deviation between old contract price and new oracle price
    int oldContractPrice = int(contractPriceBytes);
    int oraclePrice = int(oraclePriceBytes);
    int priceDiff = abs(oldContractPrice - oraclePrice);
    // Deviation threshold for oracle price difference is 0.5%
    bool exceedsDeviationThreshold = priceDiff >= (oldContractPrice / 200);
    
    // Check whether oracle sequence is a multiple of 10 (10min heartbeat)
    // Or whether the oracle price update meets deviation threshold
    require(oracleHeartbeat || exceedsDeviationThreshold, "Invalid oracle sequence, should be either a heartbeat or exceed deviation threshold");

    // Check oracle sequence is more recent than current price contract sequence
    require(oracleSeq > int(contractSeqBytes), "Invalid oracle sequence, should be more recent than current contract sequence");

    // Update state of price contract with new sequence + pricedata
    // Semantic typecast of 'oraclePriceBytes' so the concatenated result can be bytes9
    bytes9 newPriceState = 0x00 + oracleSeqBytes + bytes4(oraclePriceBytes);
    require(tx.outputs[0].nftCommitment == newPriceState, "Invalid nftCommitment");
  }

    // function sharePrice
    // Provides latest oracle price to various other contracts
    //
    // Inputs: x-priceContract, ...
    // Outputs: x-priceContract, ...

  function sharePrice() {
    // Recreate the contract at the corresponding output, as it was at the input
    require(tx.outputs[this.activeInputIndex].lockingBytecode == tx.inputs[this.activeInputIndex].lockingBytecode, "Recreate contract at corresponding output - invalid lockingBytecode");
    require(tx.outputs[this.activeInputIndex].tokenCategory == tx.inputs[this.activeInputIndex].tokenCategory, "Recreate contract at corresponding output - invalid tokenCategory");
    require(tx.outputs[this.activeInputIndex].value == 1000, "Recreate contract at corresponding output - needs to hold exactly 1000 sats");
    require(tx.outputs[this.activeInputIndex].tokenAmount == 0, "Recreate contract at corresponding output - tokenAmount must be zero");
    
    // Verify price contracts keep same contract state
    require(tx.outputs[this.activeInputIndex].nftCommitment == tx.inputs[this.activeInputIndex].nftCommitment, "Invalid nftCommitment, commitment should be replicated");
  }

    // function migrateContract
    // Migrate to new PriceContract if MigrationKey is used
    //
    // Inputs: 00-priceContract, 01-migrationKey, ...
    // Outputs: 00-newPriceContract, ...

  function migrateContract() {
    require(this.activeInputIndex == 0, "Price contract must be at input index 0");

    // Authenticate migration at inputIndex 1
    require(tx.inputs[1].tokenCategory.split(32)[0] == tokenIdMigrationKey);

    // Recreate a price contract output with new contract code
    require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory, "Recreate contract at output0 - invalid tokenCategory");
    require(tx.outputs[0].value == 1000, "Recreate contract at output0 - needs to hold exactly 1000 sats");
  }
}